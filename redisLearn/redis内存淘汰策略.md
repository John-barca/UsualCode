# 内存耗尽后 Redis 会发生什么

内存并非无限，当 Redis 服务器的内存耗尽后，继续执行请求命令，Redis会如何处理。

## 内存回收
使用 Redis 时，很多情况下某些键值对只在特定的时间内有效，为了防止这种类型的数据一直占用内存，我们可以给键值对设置有效期，Redis中可以通过 4 个独立的命令给一个键设置过期时间

- expire key ttl：将 key 值的过期时间设置为 ttl 秒
- pexpire key ttl：将 key 值的过期时间设置为 ttl 毫秒
- expireat key timestamp：将 key 值的过期时间设置为指定的 timestamp 秒数
- pexpireat key timestamp：将 key 值的过期时间设置为指定的 timestamp 的毫秒数。

不论我们使用哪一个命令，最终 Redis 底层都是使用 pexpireat 命令来实现的。另外，set 等命令也可以设置 key 的同时加上过期时间，这样可以保证设值和设过期时间的原子性。
设置了有效期后，可以通过 ttl 和 pttl 两个命令来查询剩余过期时间

- ttl key 返回 key 剩余过期秒数
- pttl key 返回 key 剩余过期的毫秒数

## 过期策略
将一个过期的键删除，一般会有三种策略：
- 定时删除：为每个键设置一个定时器，一旦过期时间到了，则将键删除。这种策略对内存很友好，但是对 CPU 不友好，因为每个定时器都会占用一定的 CPU 资源。
- 惰性删除：不管键有没有过期都不主动删除，等到每次去获取键时再判断是否过期，如果过期就删除该键，否则返回键对应的值。这种策略对内存不够友好，可能会浪费很多内存。
- 定期扫描：系统每隔一段时间就定期扫描一次，发现过期的键就进行删除。这种策略相对来说是上面两种策略的折中方案，需要注意的是这个定期的频率要结合实际情况掌控，使用这个方案有一个缺陷就是可能会出现已经过期的键也被返回。

在 Redis 当中，其选择的是策略 2 和策略 3 的综合使用。不过 Redis 的定期扫描只会扫描设置了过期时间的键，因为设置了过期时间的键 Redis 会单独存储，所以不会出现扫描所有键的情况。
```
typedef struct redisDb {
    dict *dict; // 所有的键值对
    dict *expires; // 设置了过期时间的键值对
    dict *blocking_keys; // 被阻塞的 key，如客户端执行 BLPOP 等阻塞指令时
    dict *watched_keys; // WATCHED keys
    int id; // Database ID
    // ... 省略其它属性
} redisDb;
```

## 8 种淘汰策略
假如 Redis 当中所有的键都没有过期，而且此时内存满了，那么客户端继续执行 set 等命令时 Redis 会怎么处理？Redis 当中提供了不同的淘汰策略来处理这种场景。
首先 Redis 提供了一个参数 maxmemory 来配置 Redis 最大使用内存：
```
maxmemory <bytes>
```
或者也可以通过命令 config set maxmemory 1GB 来动态修改。
如果没有设置该参数，那么在 32 位的操作系统中 Redis 最多使用 3GB 内存，而在 64 位操作系统中则不作限制。
Redis 中提供了 8 种淘汰策略，可以通过参数 maxmemory policy 进行配置。
1. volatile-lru：根据 LRU 算法删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错。
2. allkeys-lru：根据 LRU 算法删除所有的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错。
3. volatile-lfu：根据 LFU 算法删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错。
4. allkeys-lfu：根据 LFU 算法删除所有的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错。
5. volatile-random：随机删除设置了过期时间的键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错。
6. allkeys-random：随机删除所有键，直到腾出可用空间。如果没有可删除的键对象，且内存还是不够用时，则报错。
7. volatile-ttl：根据键值对象的 ttl 属性，删除最近将要过期数据，如果没有，则直接报错。
8. noeviction：默认策略，不作任何处理，直接报错。
ps：淘汰策略也可以直接使用命令 config set maxmemory-policy <策略> 来进行动态设置
## LRU算法
LRU 全称为：Least-Recently Used。即：最近最长时间未被使用，这个主要针对的是使用时间。
### Redis 改进后的 LRU 算法
在 Redis 当中，并没有采用传统的 LRU 算法，因为传统的 LRU 算法存在 2 个问题：
- 需要额外的空间进行存储
- 可能存在某些 key 值使用很频繁，但是最近没被使用，从而被 LRU 算法删除。
为了避免以上 2 个问题，Redis 当中对传统的 LRU 算法进行了改造，通过抽样的方式进行删除。
配置文件中提供了一个属性 maxmemory_samples 5，默认值就是 5，表示随机抽取 5 个key值，然后对这 5 个 key 值按照 LRU 算法进行删除，所以很明显，key 值越大，删除的准确度越高。
### Redis 如何管理热度数据
前面讲述字符串对象时，提到了 redisObject 对象中存在一个 lru 属性：
```
typedef struct redisObject {
    unsigned type:4; // 对象类型 (4位=0.5字节)
    unsigned encoding:4; // 编码 (4位=0.5字节)
    unsigned lru:LRU_BITS; // 记录对象最后一次被应用程序访问的时间
    int refcount; //引用计数，等于0时表示可以被垃圾回收(32位4字节)
    void *ptr; // 指向底层实际的数据存储结构，如：SDS等(8字节)
} robj;
```
LRU 属性是创建对象的时候写入，对象被访问到时也会进行更新。删除一个键的一般思路是使用当前时间戳减去 lru，差值最大的就优先被删除。但是 Redis 里面并不是这么做的，Redis中维护了一个全局属性 lru_clock，这个属性是通过一个全局函数 serverCron 每隔 100 毫秒执行一次来更新的，记录的是当前 Unix 时间戳。
最后决定删除的数据是通过 lru_clock 减去对象的 lru 属性而得出的。