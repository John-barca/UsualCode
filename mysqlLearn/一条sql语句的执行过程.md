# 一条 SQL 的执行过程

主要总结系统到底如何和MySQL交互，MySQL在接受到我们发送的 SQL 语句时分别做了哪些事情

## MySQL 驱动

当我们系统在和 MySQL 进行通信的时候，MySQL 驱动在底层帮助我们做了对数据库的连接，才有了后面的交互。
这样的话，在系统和 MySQL 进行交互之前，MySQL 驱动会帮我们建立好连接，然后我们只需要发送 SQL 语句就可以执行 CRUD 了。一次 SQL 请求就会建立一个连接，多个请求就会建立多个连接。
我们系统肯定是存在多个请求同时争抢连接的情况，我们的 web 系统一般都是部署在 tomcat 容器中，而 tomcat 是可以并发处理多个请求，这就会导致多个请求建立多个连接，然后使用完再都去关闭。
许多系统在通过 MySQL 驱动和 MySQL 数据库连接的时候是基于 TCP/IP 协议的，如果每个请求都是新建连接和销毁连接，那这样势必会造成不必要的浪费和性能的下降，也就是说多线程请求的时候频繁的创建和销毁连接显然是不合理的，必然会降低我们系统的性能，但是如果提供一些固定的用来连接的线程，就不需要反复的创建和销毁线程了，也就是下面提到的数据库连接池。

## 数据库连接池

数据库连接池：维护一定的连接数，方便系统获取连接，使用时就去池子中获取，用完放回池子中，我们不需要关心连接的创建与销毁，也不需要关心线程池是怎么维护这些连接。
常见的数据库连接池有Druid、C3PO、DBCP，采用连接池大大节省了不断创建与销毁线程的开销。
系统在访问MySQL数据库的时候，建立的连接并不是每次请求都会去创建的，而是从数据库连接池中去获取，解决了因为反复的创建和销毁连接而带来的性能损耗问题，业务系统都是并发的，MySQL接收请求的线程当然也不只有一个。
其实 MySQL 的架构体系中也已经提供了这样的数据库连接池，双方都是通过数据库连接池来管理各个连接，这样一方面线程之前不需要争抢连接，更重要的是不需要反复的创建和销毁连接。

## 网络连接必须由线程来处理

网络中的连接都是由线程来处理的，所谓网络连接就是一次请求，每次请求都会有相应的线程去处理，也就是说对于 SQL 语句的请求在 MySQL 中是由一个个的线程去处理的。

## SQL 接口

MySQL 中处理请求的线程在获取到请求以后获取 SQL 语句去交给 SQL 接口去处理。

## 查询解析器
```
SELECT stuName,age,sex FROM students WHERE id=1;
```
这个 SQL 是写给我们自己看的，机器并不知道在说什么，这个时候解析器就上场了。它会将 SQL 接口传递过来的 SQL 语句进行解析，翻译成 MySQL 自己能认识的语言。
现在 SQL 已经被解析成 MySQL 认识的样子，下一步 MySQL 会帮我们选择最优的查询路径。
> 最优查询路径：就是 MySQL 会按照自己认为的效率最高的方式进行查询。

## MySQL 查询优化器
MySQL会帮我们去使用他自己认为的最好的方式去优化这条 SQL 语句，并生成一条条的执行计划，比如你创建了多个索引，MySQL 会依据成本最小原则来选择使用对应的索引，这里的成本主要包括两个方面，IO 成本和 CPU 成本。
IO成本：即从磁盘把数据加载到内存的成本。默认情况下，读取数据页的IO成本是1，MySQL以页的形式读取数据，即当用到某个数据时，并不会只读取这个数据，而会把相邻的数据也一起读到内存中，这就是有名的局部性原理，所以 MySQL 每次会读取一整页，一页的成本就是1，所以 IO 的成本主要和页的大小有关。
CPU成本：将数据读入内存后，还要检测数据是否满足条件和排序等 CPU 操作的成本，显然它与行数有关，默认情况下，检测记录的成本是0.2
MySQL 优化器会计算 IO成本+CPU 成本最小的那个索引来执行。
优化器执行选出最优索引等步骤后，会去调用存储引擎接口，开始去执行被 MySQL 解析过和优化过的 SQL 语句。
## 执行器
执行器是一个非常重要的组件，因为前面组件的操作最终必须通过执行器去调用存储引擎接口才能被执行，执行器最终是根据一系列的执行计划去调用存储引擎的接口去完成 SQL 的执行。
## 存储引擎
查询优化器会调用存储引擎的接口，去执行 SQL，也就是说真正执行 SQL 的动作是在存储引擎中完成的，数据是被存放在内存或者是磁盘中的。
我们以一个更新的 SQL 语句来说明，SQL 如下
```
UPDATE students SET stuName='小强' WHERE id=1;
```
当我们系统发出这样的查询去交给 MySQL 的时候，MySQL 会按照上面的一系列流程最终通过执行器调用存储引擎去执行。在执行这个 SQL 的时候 SQL 语句对应的数据要么是在内存中，要么是在磁盘中，如果直接在磁盘中操作，那这样的随机 IO 读写的速度肯定让人无法接受的，所以每次在执行 SQL 的时候都会将其数据加载到内存中，这块内存就是 InnoDB 中一个非常重要的组件：缓冲池 Buffer Pool

### Buffer Pool
Buffer Pool(缓冲池)是 InnoDB 存储引擎中非常重要的内存结构，顾名思义，缓冲池其实是类似 Redis 一样的作用，起到一个缓存的作用，因为我们都知道 MySQL 的数据最终是存储在磁盘中的，如果没有这个 Buffer Pool 那么我们每次的数据库请求都会在磁盘中查找，这样必然会存在 IO 操作。但是有了 Buffer Pool 就是我们第一次在查询的时候会将查询的结果存到 Buffer Pool中，这样后面再有请求的时候就会先从缓冲池中去查询，如果没有再去磁盘中查找，然后再放到 Buffer Pool 中。
当前这条 SQL 语句的执行步骤大致是这样子的
1. innodb 存储引擎会在缓冲池中查找 id=1 这条数据是否存在。
2. 发现不存在，就会去磁盘中加载，并将其存放在缓冲池中。

### undo 日志文件：记录数据被修改前的样子
undo 意思就是没有做，没发生的意思，undo log 就是没有发生事情(原本事情是什么)的一些日志
我们刚刚已经说了，在准备更新一条语句的时候，该条语句已经被加载到 Buffer Pool 中了，实际上在将该条语句加载到 Buffer Pool 中的时候同时会往 undo 日志文件中插入一条日志，也就是将 id=1 的这条记录的原来的值记录下来。
目的：Innodb 存储引擎的最大特点就是支持事务，如果本次更新失败，也就是事务提交失败，那么该事务中的所有操作都必须回滚到执行前的样子，也就是当事务失败的时候，不会对原始数据有影响。
到这一步，我们执行的 SQL 语句已经被加载到 Buffer Pool 中了，然后开始更新这条语句，更新的操作实际是在 Buffer Pool 中执行的，按照平时开发的一套理论，缓冲池中的数据和数据库中的数据不一致时候，我们就认为缓存中的数据是脏数据。此时 Buffer Pool 的这条数据确实就是脏数据。这种情况 MySQL 是如何处理。

### redo 日志文件：记录数据被修改后的样子
除了从磁盘中加载文件和将操作前的记录保存到 undo 日志文件中，其他的操作是在内存中完成的，内存中的数据的特点就是：断电丢失，如果此时 MySQL 所在的服务宕机，那么 Buffer Pool 中的数据会全部丢失，这个时候 redo 日志文件就有作用了。
> PS：redo 日志文件是 Innodb 特有的，他是存储引擎级别的，不是 MySQL 级别的。
redo 记录的是数据修改之后的值，不管事务是否提交都会记录下来，例如，此时将要做的是
```
update students set stuName='keline' where id=1;
```
那么这条操作就会被记录到 redo log buffer 中，MySQL 为了提高效率，所以将这些操作都先放在内存中去完成，然后会在某个时机将其持久化到磁盘中。
MySQL的执行器调用存储引擎是怎么将一条 SQL 加载到缓冲池和记录哪些日志，流程如下：
1. 准备更新一条 SQL 语句。
2. MySQL (Innodb)会先去缓冲池(Buffer Pool)中去查找这条数据，没找到就会去磁盘中找，如果查找到就会将这条数据加载到缓冲池(Buffer Pool)中。
3. 在加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中。
4. Innodb 会在 Buffer Pool 中执行更新操作。
5. 更新后的数据会记录在 redo log buffer 中。
如上的这些步骤都是在正常情况下的操作，但是程序的设计和优化不仅是为了这些正常情况而去做的，也是为了那些临界区和极端情况下出现的问题而去优化设计的。
这个时候如果服务器宕机，没关系，MySQL 会认为本次事务是失败的，所以数据依旧是更新前的样子，并不会有任何的影响。
语句也更新好了，需要提交本次的事务，因为只要事务成功提交了，才会将最后的变更保存到数据库，在提交事务前仍然会具有相关的其他操作。
将 redo Log Buffer 中的数据持久化到磁盘中，就是将 redo log buffer 中的数据写入到 redo log 磁盘文件中，一般情况下，redo log buffer 数据写入磁盘的策略是立即刷入磁盘。
如果 redo log buffer 刷入磁盘后，数据库服务器宕机了，更新的数据怎么办？此时数据是在内存中，数据丢失了吗？不，这次数据不会丢失，因为 redo log buffer 中的数据已经写入磁盘，已经被持久化，就算数据库宕机了，在下次重启的时候 MySQL 也会将 redo 日志文件内容恢复到 Buffer Pool 中。
目前为止，从执行器开始调用存储引擎接口做了哪些事情呢？
1. 准备更新一条语句
2. MySQL(Innodb)会先去缓冲池(Buffer Pool)中去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池(BufferPool)中
3. 在加载到 BufferPool的同时，会将这条数据的原始记录保存到 undo 日志文件中
4. innodb 会在 Buffer Pool 中执行更新操作
5. 更新后的数据会记录在 redo log buffer 中
6. MySQL 提交事务的时候，会将 redo log buffer 中的数据写入到 redo 日志文件中刷磁盘可以通过 innodb_flush_log_at_trx_commit 参数来设置
值为 0 表示不刷入磁盘
值为 1 表示立即刷入磁盘
值为 2 表示先刷到 os cache
7. MySQL 重启时会将 redo 日志恢复到缓冲池中

## binlog：MySQL 级别的日志文件，记录整个操作过程
redo log 是 Innodb 存储引擎特有的日志文件，而 bin log 属于是 MySQL 级别的日志。redo log 记录的东西是偏向于物理性质的，如：“对什么数据，做了什么修改”。 bin log是偏向于逻辑性质的，类似于：“对 students 表中的 id 为 1 的记录做了更新操作”两者的主要特点总结如下：
|  性质   | redo Log  | bin Log |
|  ----  | ----  |  ----  |
| 文件大小  | redo log的大小是固定的(配置中也可以设置，一般默认即可) | bin log 可以通过配置参数max_bin log_size设置每个bin log文件的大小(但是一般不这么改) |
| 实现方式  | redo log是Innodb引擎层实现的 | bin log是 MySQL 层实现的，所有引擎都可以使用 bin log 日志 |
| 记录方式  | redo log采用循环写的方式记录，当写到结尾时，会循环从头写 | bin log 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上 | 
| 使用场景  | redo log适用于崩溃恢复(crash-safe)(类似于 redis 持久化特征) | bin log 适用于主从复制和数据恢复 |
**bin log 文件是如何刷入磁盘的？**
bin log的刷盘是有相关的策略的，策略可以通过sync_bin log来修改，默认为0，表示先写入os cache，也就是说在提交事务的时候，数据不会直接到磁盘中，这样如果宕机bin log数据仍然会丢失，所以建议将 sync_bin log设置为1表示**直接将数据写入到磁盘**文件中。
刷入 bin log 有以下几种模式：
1. STATMENT
基于 SQL 语句的复制，每一条会修改数据的SQL语句会记录到bin log中。
**优点：**不需要记录每一行的变化，减少了 bin log 日志量，节约了IO，从而提高了性能
**缺点：**在某些情况下会导致主从数据不一致，比如执行sysdate()、slepp()等
2. ROW
基于行的复制，不记录每条SQL语句的上下文信息，仅需记录哪条数据被修改了
**优点：**不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题
**缺点：**会产生大量的日志，尤其是alter table的时候会让日志暴涨
3. MIXED
基于 STATMENT 和 ROW 两种模式的混合复制，一般的复制使用 STAEMENT
